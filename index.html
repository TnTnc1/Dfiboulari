<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Le D√©fi Boulari - Version R√©aliste</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&family=Handlee&family=Courier+Prime:wght@700&display=swap');

    :root{
      --ui-bg: rgba(0,0,0,0.70);
      --ui-border: rgba(255,255,255,0.85);
      --ui-shadow: rgba(0,0,0,0.35);
      --accent: #2d89ef;
      --good: #2ecc71;
      --warn: #f1c40f;
      --bad: #ff4757;
    }

    body{
      margin:0; padding:0; overflow:hidden;
      background:#121212;
      font-family:'Roboto Condensed', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      touch-action:none;
      user-select:none;
    }

    #game-container{
      position:relative;
      width:100vw;
      height:100vh;
      overflow:hidden;
      background: url('https://i.postimg.cc/VL0sLRv5/IMG-3343.jpg') no-repeat center center;
      background-size:cover;
    }

    .game-overlay{
      position:absolute; inset:0;
      background: rgba(20, 20, 20, 0.80);
      z-index:0;
    }

    canvas{
      display:block;
      width:100%;
      height:100%;
      position:relative;
      z-index:1;
    }

    .ui-layer{
      position:absolute; inset:0;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      z-index:20;
    }
    .interactive{ pointer-events:auto; }
    .hidden{ display:none !important; }

    /* Intro */
    #introScreen{
      position:absolute; inset:0;
      background:black;
      z-index:100;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    #introVideo{ width:100%; height:100%; object-fit:cover; }

    .intro-controls{
      position:absolute; bottom:30px; right:30px;
      z-index:101;
      display:flex; gap:10px;
      pointer-events:auto;
    }

    .btn-sound-intro{
      position:absolute; top:20px; left:20px;
      z-index:101;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.9);
      color:#fff;
      padding:8px 14px;
      border-radius:999px;
      cursor:pointer;
      pointer-events:auto;
      font-size:0.85rem;
      display:flex;
      align-items:center;
      gap:8px;
      backdrop-filter: blur(6px);
    }

    .btn-skip{
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.9);
      color:#fff;
      padding:10px 22px;
      border-radius:999px;
      cursor:pointer;
      font-family:'Roboto Condensed', sans-serif;
      text-transform:uppercase;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .2s ease;
      pointer-events:auto;
    }
    .btn-skip:hover{ background: rgba(255,255,255,0.10); }
    .btn-skip:active{ transform: translateY(1px); }

    /* Global buttons */
    .btn-round{
      position:absolute;
      width:50px; height:50px;
      background: rgba(255,255,255,0.95);
      border-radius:50%;
      display:flex; justify-content:center; align-items:center;
      font-size:22px;
      cursor:pointer;
      z-index:200;
      box-shadow: 0 10px 20px rgba(0,0,0,0.25);
      pointer-events:auto;
      border: 2px solid rgba(0,0,0,0.25);
    }
    .btn-mute{ top:20px; right:20px; }
    .btn-fullscreen{ top:20px; left:20px; }

    /* Rotate overlay */
    #rotateOverlay{
      display:none;
      position:fixed; inset:0;
      background:#121212;
      color:white;
      z-index:9999;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      text-align:center;
      padding:20px;
    }

    @media screen and (orientation: portrait) and (max-width: 1024px){
      #rotateOverlay{ display:flex; }
      #gameUI, #startScreen, #endScreen, #introScreen{ display:none !important; }
    }

    /* HUD */
    .hud-top{
      position:absolute; top:10px; left:10px; right:70px;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
    }

    .info-box{
      background: var(--ui-bg);
      color:#fff;
      padding:10px 14px;
      border-radius:12px;
      border: 1px solid var(--ui-border);
      font-size:1.05rem;
      box-shadow: 0 10px 20px var(--ui-shadow);
      backdrop-filter: blur(10px);
    }

    .btn-quit{
      background:#e74c3c;
      color:white;
      padding:10px 14px;
      border-radius:12px;
      border: 1px solid rgba(255,255,255,0.85);
      font-size:1rem;
      cursor:pointer;
      pointer-events:auto;
      margin-right:10px;
      box-shadow: 0 6px 0 #c0392b;
      transition: transform 0.1s;
    }
    .btn-quit:active{ transform: translateY(2px); box-shadow:none; }

    .penalty-flash{ color: var(--bad); animation: flash 0.5s; }
    @keyframes flash{ 0%{ transform:scale(1);} 50%{ transform:scale(1.35);} 100%{ transform:scale(1);} }

    /* Consignes (neutre) */
    .hint-box{
      position:absolute;
      top:62px;
      left:10px;
      max-width:min(600px, 92vw);
      pointer-events:none;
    }
    .hint-inner{
      background: rgba(255,255,255,0.92);
      color:#111;
      padding:10px 12px;
      border-radius:16px;
      border: 1px solid rgba(0,0,0,0.12);
      box-shadow: 0 12px 30px rgba(0,0,0,0.20);
      font-weight:700;
      font-size:0.95rem;
      display:flex;
      gap:10px;
      align-items:flex-start;
      font-family: 'Handlee', cursive;
    }
    .hint-icon{
      width:34px;
      height:34px;
      border-radius:12px;
      background: rgba(45,137,239,0.12);
      display:flex;
      align-items:center;
      justify-content:center;
      border: 1px solid rgba(45,137,239,0.25);
      flex: 0 0 auto;
      font-size:18px;
    }

    /* Feedback popup */
    .feedback-popup{
      position:absolute; top:40%; left:50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.88);
      color:white;
      padding:18px 20px;
      border-radius:16px;
      text-align:center;
      animation: popIn 0.25s ease;
      border: 1px solid rgba(255,255,255,0.85);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      pointer-events:none;
    }
    @keyframes popIn{
      from{ transform: translate(-50%, -50%) scale(0.92); opacity:0; }
      to{ transform: translate(-50%, -50%) scale(1); opacity:1; }
    }

    /* Controls area */
    .controls-area{
      position:absolute;
      bottom:18px;
      width:100%;
      height:180px;
      pointer-events:none;
      display:flex;
      justify-content:space-between;
      padding:0 18px;
      gap:18px;
    }

    .wheel-zone{
      width:160px; height:160px;
      background: rgba(0,0,0,0.35);
      border-radius:50%;
      border: 2px solid rgba(255,255,255,0.30);
      position:relative;
      pointer-events:auto;
      align-self:flex-end;
      backdrop-filter: blur(8px);
      box-shadow: 0 16px 40px rgba(0,0,0,0.35);
    }
    .wheel-visual{
      width:100%; height:100%;
      border-radius:50%;
      position:relative;
      transition: transform 0.08s ease-out;
      background:
        radial-gradient(circle at center, rgba(255,255,255,0) 60%, rgba(255,255,255,0.18) 61%, rgba(255,255,255,0.10) 100%),
        linear-gradient(0deg, transparent 46%, rgba(255,255,255,0.14) 46%, rgba(255,255,255,0.14) 54%, transparent 54%),
        linear-gradient(90deg, transparent 46%, rgba(255,255,255,0.14) 46%, rgba(255,255,255,0.14) 54%, transparent 54%);
    }
    .wheel-visual::after{
      content:'';
      position:absolute; top:50%; left:50%;
      transform: translate(-50%,-50%);
      width:42px; height:42px;
      background: rgba(45,137,239,0.95);
      border-radius:50%;
      border: 2px solid rgba(255,255,255,0.9);
      box-shadow: 0 10px 20px rgba(0,0,0,0.22);
    }
    .wheel-knob{
      width:26px; height:26px;
      background: rgba(45,137,239,0.95);
      border-radius:50%;
      position:absolute;
      top:10px; left:50%;
      transform: translateX(-50%);
      border:2px solid rgba(255,255,255,0.85);
      box-shadow: 0 10px 18px rgba(0,0,0,0.25);
    }

    .pedals-zone{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      justify-content:flex-end;
      gap:10px;
      pointer-events:auto;
    }
    .gear-stick{
      width:62px; height:62px;
      background: rgba(0,0,0,0.45);
      border-radius:14px;
      color:white;
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:1.5rem;
      border: 1px solid rgba(255,255,255,0.35);
      cursor:pointer;
      box-shadow: 0 14px 30px rgba(0,0,0,0.25);
      backdrop-filter: blur(8px);
    }
    .gear-d{ background: rgba(46, 204, 113, 0.28); }
    .gear-r{ background: rgba(231, 112, 85, 0.28); }

    .pedal-row{ display:flex; gap:14px; }
    .pedal{
      width:76px; height:102px;
      border-radius:14px;
      border: 1px solid rgba(255,255,255,0.35);
      display:flex;
      justify-content:center;
      align-items:center;
      color:white;
      font-size:1.05rem;
      cursor:pointer;
      transition: transform 0.08s;
      box-shadow: 0 16px 40px rgba(0,0,0,0.25);
      backdrop-filter: blur(8px);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .pedal:active, .pedal.active-key{ transform: translateY(5px); }
    .brake{ background: rgba(214, 48, 49, 0.36); }
    .gas{ background: rgba(0, 184, 148, 0.36); }

    @media (max-height: 500px){
      .controls-area{ height:140px; bottom:10px; }
      .wheel-zone{ width:120px; height:120px; }
      .pedal{ width:64px; height:82px; font-size:0.95rem; }
      .gear-stick{ width:52px; height:52px; font-size:1.2rem; }
    }

    /* Menus */
    .modal-bg{
      background: rgba(0,0,0,0.82);
      display:flex;
      justify-content:center;
      align-items:center;
      backdrop-filter: blur(10px);
    }
    .menu-card{
      background: rgba(245,246,250,0.98);
      border-radius:18px;
      padding:1.4rem;
      text-align:center;
      max-width:520px;
      width:95%;
      max-height:95vh;
      overflow-y:auto;
      box-shadow: 0 30px 80px rgba(0,0,0,0.55);
      border-top: 10px solid var(--accent);
      position:relative;
    }
    .input-field{
      width:100%;
      padding:12px;
      margin:14px 0;
      border: 2px solid #dcdde1;
      border-radius:12px;
      font-size:1.15rem;
      text-align:center;
      font-family:'Handlee', cursive;
      background:#fff;
    }
    .btn-main{
      background: linear-gradient(to bottom, #3498db, #2980b9);
      color:white;
      font-size:1.2rem;
      padding:12px 26px;
      border-radius:999px;
      border:none;
      width:100%;
      cursor:pointer;
      text-transform: uppercase;
      box-shadow: 0 6px 0 #1c5980;
      text-shadow: 1px 1px 0 rgba(0,0,0,0.28);
      transition: transform 0.08s;
    }
    .btn-main:active{ transform: translateY(4px); box-shadow:none; }

    @media (max-height: 500px){
      .menu-card{ padding:0.8rem; max-width:460px; }
      .menu-logo{ width:80px !important; }
      .menu-desc{ display:none; }
      .input-field{ padding:8px !important; margin:8px 0 !important; }
      .btn-main{ padding:9px 18px !important; font-size:1rem !important; }
    }

    /* Certificate */
    .certificate{
      background:#fffdf0;
      border: 8px double #2c3e50;
      padding:20px;
      position:relative;
      font-family:'Courier Prime', monospace;
      color:#333;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
    }
    .stamp{
      position:absolute;
      bottom:20px;
      right:20px;
      width:84px;
      height:84px;
      border:4px solid #c0392b;
      border-radius:50%;
      color:#c0392b;
      display:flex;
      justify-content:center;
      align-items:center;
      font-weight:bold;
      transform: rotate(-20deg);
      opacity:0.85;
      font-size:14px;
      text-align:center;
    }
  </style>
</head>

<body>
  <div id="rotateOverlay">
    <div class="text-6xl mb-4">üì±‚ÜîÔ∏è</div>
    <h1 class="text-2xl font-bold mb-2">TOURNEZ VOTRE APPAREIL</h1>
    <p>Le D√©fi Boulari se joue en mode paysage pour une meilleure visibilit√©.</p>
  </div>

  <div id="game-container">
    <button id="globalMuteBtn" class="btn-round btn-mute" title="Son">üîä</button>
    <button id="fsToggleBtn" class="btn-round btn-fullscreen" title="Plein √©cran">‚õ∂</button>

    <div id="introScreen">
      <button id="unmuteIntroBtn" class="btn-sound-intro">üîä Activer le son</button>
      <video id="introVideo" playsinline autoplay muted>
        <source src="https://res.cloudinary.com/drjkiqihn/video/upload/v1764123464/Cr%C3%A9ation_vid%C3%A9o_intro_Le_D%C3%A9fi_Boulari__c4zxhr.mp4" type="video/mp4">
      </video>
      <div class="intro-controls">
        <button id="skipBtn" class="btn-skip">Passer l'intro ‚è©</button>
      </div>
    </div>

    <div id="gameOverlay" class="game-overlay hidden"></div>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="gameUI" class="ui-layer hidden">
      <div class="hud-top">
        <div class="flex items-center">
          <button id="quitBtn" class="btn-quit">‚úï Menu</button>
          <div class="info-box" id="levelName">Niveau 1</div>
        </div>
        <div class="info-box" style="color: var(--warn);">‚è±Ô∏è <span id="timerVal">00.00</span></div>
      </div>

      <!-- Consignes neutres -->
      <div class="hint-box">
        <div class="hint-inner" id="hintBox">
          <div class="hint-icon">üìù</div>
          <div>
            <div class="text-[13px] text-black/70 font-sans font-bold uppercase tracking-wide">Consigne</div>
            <div id="monitorMsg" class="leading-snug">Pr√©pare-toi‚Ä¶</div>
          </div>
        </div>
      </div>

      <div id="feedbackUI" class="feedback-popup hidden">
        <h2 class="text-2xl font-bold mb-1" id="fbTitle">OK</h2>
        <p class="text-base" id="fbText">...</p>
      </div>

      <!-- Controls -->
      <div class="controls-area">
        <div class="wheel-zone" id="wheelZone">
          <div id="wheelVisual" class="wheel-visual">
            <div class="wheel-knob"></div>
          </div>
        </div>

        <div class="pedals-zone">
          <div class="gear-stick gear-d" id="gearStick">D</div>
          <div class="pedal-row">
            <div class="pedal brake" id="btnBrake">Frein</div>
            <div class="pedal gas" id="btnGas">Gaz</div>
          </div>
        </div>
      </div>

      <div class="absolute bottom-2 w-full text-center text-white/40 text-xs md:block hidden">
        Clavier : Fl√®ches (ou ZQSD) + Espace/Shift (R/D)
      </div>
    </div>

    <!-- Start screen -->
    <div id="startScreen" class="ui-layer interactive modal-bg hidden">
      <div class="menu-card">
        <div class="w-full mb-3 overflow-hidden rounded-xl border border-gray-200 shadow-sm">
          <img src="https://i.postimg.cc/VL0sLRv5/IMG-3343.jpg" alt="Le D√©fi Boulari" class="menu-logo w-44 mx-auto h-auto object-contain block">
        </div>

        <h1 class="text-3xl font-bold mb-1" style="color:#2980b9;">LE D√âFI BOULARI</h1>
        <div class="menu-desc text-gray-600 font-bold mb-3 italic">Passe les 3 √©preuves et fais le meilleur chrono !</div>

        <div class="bg-gray-50 p-3 rounded-xl mb-3 text-left text-sm border border-gray-200 shadow-inner">
          <p class="font-bold text-gray-700 mb-1">üèÅ R√®gles</p>
          <ul class="text-gray-700 text-xs list-disc ml-4 space-y-1">
            <li>Le chrono d√©marre au vert sur l‚Äô√©preuve 1.</li>
            <li>Chaque choc = +5s. Slalom rat√© = +2s.</li>
            <li>Objectif : pr√©cision + vitesse.</li>
          </ul>
        </div>

        <input type="text" id="playerNameInput" class="input-field" placeholder="Ton pr√©nom / pseudo" maxlength="15">
        <button class="btn-main" id="startBtn">Passer l'examen</button>
      </div>
    </div>

    <!-- End screen -->
    <div id="endScreen" class="ui-layer interactive modal-bg hidden">
      <div class="menu-card" style="max-width:520px; border-top-color: var(--good);">
        <div class="certificate">
          <h2 class="text-2xl font-bold text-center border-b-2 border-black pb-2 mb-4">PERMIS PROVISOIRE</h2>

          <div class="text-left space-y-2 text-sm">
            <p>PILOTE: <span class="font-bold text-lg" id="certName">---</span></p>
            <p>DATE: <span id="certDate">--/--/----</span></p>

            <div class="flex justify-between items-end mt-4 bg-gray-100 p-2 rounded">
              <div>
                <p class="text-xs text-gray-500">P√âNALIT√âS</p>
                <p class="text-red-600 font-bold text-xl" id="certPenalties">+0s</p>
              </div>
              <div class="text-right">
                <p class="text-xs text-gray-500">TEMPS FINAL</p>
                <p class="text-4xl font-bold text-blue-600" id="certTime">00.00</p>
              </div>
            </div>
            <div class="text-right text-xs text-gray-400 mt-2">ID: <span id="certId">#0000</span></div>
          </div>

          <div class="stamp">VALID√â<br>AUTO<br>√âCOLE</div>
        </div>

        <p class="text-gray-600 text-xs mt-4 mb-2 font-bold">üì∏ Fais une capture et poste-la en commentaire !</p>
        <button class="btn-main" id="restartBtn" style="background:#27ae60;">R√©essayer</button>
      </div>
    </div>
  </div>

  <script>
    // ============================================================
    //  D√©fi Boulari - Version R√©aliste (fichier unique)
    // ============================================================

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // ----------------------------
    // Audio
    // ----------------------------
    let isMuted = false;

    function playSound(type) {
      if (!audioCtx || isMuted) return;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;

      if (type === 'crash') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.45);
        gain.gain.setValueAtTime(0.28, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.45);
        osc.start();
        osc.stop(now + 0.45);
      } else if (type === 'win') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(420, now);
        osc.frequency.linearRampToValueAtTime(860, now + 0.18);
        gain.gain.setValueAtTime(0.22, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.18);
        osc.start();
        osc.stop(now + 0.18);
      } else if (type === 'click') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(220, now);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.05);
        osc.start();
        osc.stop(now + 0.05);
      }
    }

    function toggleMute() {
      isMuted = !isMuted;
      const btn = document.getElementById('globalMuteBtn');
      const video = document.getElementById('introVideo');

      if (isMuted) {
        btn.innerText = 'üîá';
        if (video) video.muted = true;
        audioCtx.suspend();
      } else {
        btn.innerText = 'üîä';
        if (video) video.muted = false;
        audioCtx.resume();
      }
    }

    document.getElementById('globalMuteBtn').addEventListener('click', function() {
      toggleMute();
      this.blur();
    });

    // ----------------------------
    // Fullscreen
    // ----------------------------
    function toggleFullScreen() {
      const doc = window.document;
      const docEl = doc.documentElement;
      const requestFullScreen =
        docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
      const cancelFullScreen =
        doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

      if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
        if (requestFullScreen) requestFullScreen.call(docEl);
      } else {
        if (cancelFullScreen) cancelFullScreen.call(doc);
      }
    }

    document.getElementById('fsToggleBtn').addEventListener('click', function() {
      toggleFullScreen();
      this.blur();
    });

    // ----------------------------
    // Assets (SVG inline)
    // ----------------------------
    let asphaltPattern;

    const carImg = new Image();
    carImg.src =
      "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='60' viewBox='0 0 30 60'%3E%3Cpath d='M3,12 Q3,6 9,6 L21,6 Q27,6 27,12 L27,51 Q27,57 21,57 L9,57 Q3,57 3,51 Z' fill='%23ffffff' stroke='%23bdc3c7' stroke-width='1'/%3E%3Crect x='5' y='15' width='20' height='9' rx='1' fill='%232c3e50'/%3E%3Crect x='5' y='39' width='20' height='7' rx='1' fill='%232c3e50'/%3E%3Crect x='3' y='6' width='5' height='3' rx='0.5' fill='%23f1c40f'/%3E%3Crect x='22' y='6' width='5' height='3' rx='0.5' fill='%23f1c40f'/%3E%3Crect x='3' y='54' width='5' height='3' rx='0.5' fill='%23e74c3c'/%3E%3Crect x='22' y='54' width='5' height='3' rx='0.5' fill='%23e74c3c'/%3E%3Ctext x='15' y='35' font-family='Arial' font-size='8' fill='%233498db' text-anchor='middle' transform='rotate(-90 15 35)'%3EAUTO-ECOLE%3C/text%3E%3Cpath d='M6,27 L24,27' stroke='rgba(0,0,0,0.1)' stroke-width='1'/%3E%3C/svg%3E";

    const carObsImg = new Image();
    carObsImg.src =
      "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='60' viewBox='0 0 30 60'%3E%3Cpath d='M3,12 Q3,6 9,6 L21,6 Q27,6 27,12 L27,51 Q27,57 21,57 L9,57 Q3,57 3,51 Z' fill='%23e74c3c' stroke='%23c0392b' stroke-width='1'/%3E%3Crect x='5' y='15' width='20' height='9' rx='1' fill='%232c3e50'/%3E%3Crect x='5' y='39' width='20' height='7' rx='1' fill='%232c3e50'/%3E%3C/svg%3E";

    const coneImg = new Image();
    coneImg.src =
      "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' viewBox='0 0 20 20'%3E%3Ccircle cx='10' cy='10' r='9' fill='%23e67e22' stroke='%23d35400' stroke-width='1'/%3E%3Ccircle cx='10' cy='10' r='5' fill='white'/%3E%3C/svg%3E";

    // ----------------------------
    // Game params / state
    // ----------------------------
    const WHEELBASE = 40;
    const MAX_STEER = 0.6;

    let state = 'INTRO'; // INTRO, MENU, PLAYING, TRANSITION, FINISHED
    let currentLevel = 0;
    let playerName = "";

    // ‚úÖ chrono : d√©marre seulement quand on autorise (au vert)
    let startTime = 0;      // timestamp (ms) au moment du d√©part officiel
    let timerRunning = false;

    let penaltyTime = 0;
    let winStartTime = 0;
    let gameLoopId = null;
    let lastCrashTime = 0;
    let hasReversed = false;

    // entities
    let car = {
      x: 0, y: 0,
      angle: 0,
      speed: 0,
      steering: 0,
      gear: 1, // 1 = D, -1 = R
      inputs: { gas: false, brake: false, steerTarget: 0 }
    };

    let obstacles = [];
    let targetZone = null;

    // meta niveau
    const levelMeta = {
      slalomGates: [],
      slalomLastX: 0,
      traffic: { phase: 'red', t0: 0, started: false }
    };

    const getCX = (pct) => canvas.width * (pct / 100);
    const getCY = (pct) => canvas.height * (pct / 100);

    // ----------------------------
    // Levels
    // ----------------------------
    const LEVELS = [
      // 1) FEU TRICOLORE
      {
        title: "1. Le Feu",
        msg: "Attends le VERT, puis d√©marre et arr√™te-toi dans la zone.",
        setup: () => {
          const roadY = getCY(55);
          const roadH = 180;

          // placement voiture
          car.x = getCX(12);
          car.y = roadY + 40;
          car.angle = 0;

          // zone d'arr√™t
          targetZone = { x: getCX(70), y: roadY + 40, w: 95, h: 70, angle: 0 };

          // murs
          obstacles.push({ type: 'wall', x: getCX(50), y: roadY - roadH/2 - 10, w: getCX(100), h: 20 });
          obstacles.push({ type: 'wall', x: getCX(50), y: roadY + roadH/2 + 10, w: getCX(100), h: 20 });

          // config feu
          levelMeta.traffic.phase = 'red';
          levelMeta.traffic.t0 = performance.now();
          levelMeta.traffic.started = false;

          // ‚úÖ chrono OFF tant que pas vert
          timerRunning = false;
          startTime = 0;

          setMonitor("Feu ROUGE‚Ä¶ ne bouge pas. Le chrono d√©marre au VERT.");
        },
        update: (dt) => {
          // cycle : rouge 1.6s -> orange 0.8s -> vert
          const t = (performance.now() - levelMeta.traffic.t0) / 1000;
          if (t < 1.6) levelMeta.traffic.phase = 'red';
          else if (t < 2.4) levelMeta.traffic.phase = 'amber';
          else levelMeta.traffic.phase = 'green';

          if (!levelMeta.traffic.started) {
            if (levelMeta.traffic.phase === 'green') {
              levelMeta.traffic.started = true;
              timerRunning = true;
              startTime = Date.now();
              setMonitor("VERT ‚úÖ Go ! Arr√™te-toi dans la zone.");
              playSound('click');
            } else {
              if (levelMeta.traffic.phase === 'red') setMonitor("Feu ROUGE‚Ä¶ attends.");
              else setMonitor("ORANGE‚Ä¶ pr√™t !");
            }
          }
        }
      },

      // 2) SLALOM (portes)
      {
        title: "2. Le Slalom",
        msg: "Passe ENTRE les 2 plots. Une porte sur deux, altern√©e haut/bas.",
        setup: () => {
          const roadY = getCY(55);
          const roadH = 220;

          car.x = getCX(10);
          car.y = roadY;
          car.angle = 0;

          targetZone = { x: getCX(90), y: roadY, w: 120, h: 90, angle: 0 };

          obstacles.push({ type: 'wall', x: getCX(50), y: roadY - roadH/2 - 10, w: getCX(100), h: 20 });
          obstacles.push({ type: 'wall', x: getCX(50), y: roadY + roadH/2 + 10, w: getCX(100), h: 20 });

          // param√®tres
          const gatesTotal = 10;         // portes th√©oriques -> on garde 1/2 => 5 portes
          const xStart = getCX(28);
          const xEnd = getCX(78);
          const offsetY = 70;            // alternance haut/bas
          const openingHalf = 45;        // ouverture (plus grand = plus facile)
          const margin = 18;

          const roadTop = roadY - roadH/2 + margin;
          const roadBot = roadY + roadH/2 - margin;

          levelMeta.slalomGates = [];
          levelMeta.slalomLastX = car.x;

          let side = -1;

          for (let i = 0; i < gatesTotal; i++) {
            if (i % 2 === 1) continue; // ‚úÖ une porte sur deux

            const t = i / (gatesTotal - 1);
            const x = xStart + (xEnd - xStart) * t;

            let openCenterY = roadY + side * offsetY;
            openCenterY = Math.max(roadTop + openingHalf, Math.min(roadBot - openingHalf, openCenterY));

            const yTop = openCenterY - openingHalf;
            const yBot = openCenterY + openingHalf;

            obstacles.push({ type: 'cone', x, y: yTop });
            obstacles.push({ type: 'cone', x, y: yBot });

            levelMeta.slalomGates.push({ x, yTop, yBot, passed: false });
            side *= -1;
          }

          setMonitor("Slalom : vise l‚Äôouverture entre les 2 plots.");
        },
        update: (dt) => {
          // p√©nalit√© douce si on ‚Äúrate‚Äù une porte
          const lastX = levelMeta.slalomLastX;
          const nowX = car.x;

          if (nowX > lastX) {
            for (const g of levelMeta.slalomGates) {
              if (g.passed) continue;
              if (lastX <= g.x && nowX > g.x) {
                g.passed = true;

                const tol = 10;
                const ok = (car.y > g.yTop + tol && car.y < g.yBot - tol);

                if (!ok) {
                  penaltyTime += 2;
                  playSound('click');
                  flashPenalty("+2s (porte rat√©e)");
                }
              }
            }
          }
          levelMeta.slalomLastX = nowX;
        }
      },

      // 3) CR√âNEAU
      {
        title: "3. Le Cr√©neau",
        msg: "Marche arri√®re obligatoire. Gare-toi dans la zone.",
        setup: () => {
          const roadY = getCY(62);

          car.x = getCX(12);
          car.y = roadY + 40;
          car.angle = 0;

          const targetX = getCX(55);
          targetZone = { x: targetX, y: roadY - 35, w: 100, h: 70, angle: 0 };

          // trottoir haut
          obstacles.push({ type: 'wall', x: getCX(50), y: roadY - 88, w: getCX(100), h: 20 });

          // voitures de chaque c√¥t√© (stationn√©es)
          obstacles.push({ type: 'car', x: targetX - 120, y: roadY - 35, angle: -Math.PI/2 });
          obstacles.push({ type: 'car', x: targetX + 120, y: roadY - 35, angle: -Math.PI/2 });

          setMonitor("Cr√©neau : passe en R puis rentre dans la zone.");
        }
      }
    ];

    // ----------------------------
    // Helpers UI
    // ----------------------------
    const monitorEl = document.getElementById('monitorMsg');
    const fb = document.getElementById('feedbackUI');

    function setMonitor(text) {
      if (monitorEl) monitorEl.innerText = text;
    }

    function flashPenalty(text) {
      const timerEl = document.getElementById('timerVal');
      if (timerEl) {
        timerEl.classList.add('penalty-flash');
        setTimeout(() => timerEl.classList.remove('penalty-flash'), 500);
      }

      if (fb) {
        document.getElementById('fbTitle').innerText = "P√âNALIT√â";
        document.getElementById('fbText').innerText = text;
        document.getElementById('fbTitle').style.color = "#f1c40f";
        document.getElementById('fbText').style.color = "#fff";
        fb.classList.remove('hidden');
        setTimeout(() => fb.classList.add('hidden'), 850);
      }
    }

    // ----------------------------
    // Asphalt pattern
    // ----------------------------
    function generateAsphalt() {
      const pCanvas = document.createElement('canvas');
      pCanvas.width = 96;
      pCanvas.height = 96;
      const pCtx = pCanvas.getContext('2d');

      pCtx.fillStyle = '#444';
      pCtx.fillRect(0,0,pCanvas.width,pCanvas.height);

      for (let i=0;i<360;i++){
        const v = Math.random();
        pCtx.fillStyle = v > 0.66 ? '#555' : (v > 0.33 ? '#3a3a3a' : '#2f2f2f');
        pCtx.fillRect(Math.random()*pCanvas.width, Math.random()*pCanvas.height, 2, 2);
      }

      // petites fissures
      pCtx.strokeStyle = 'rgba(255,255,255,0.04)';
      pCtx.lineWidth = 1;
      for (let i=0;i<10;i++){
        pCtx.beginPath();
        pCtx.moveTo(Math.random()*96, Math.random()*96);
        pCtx.lineTo(Math.random()*96, Math.random()*96);
        pCtx.stroke();
      }

      asphaltPattern = ctx.createPattern(pCanvas, 'repeat');
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      generateAsphalt();
    }
    window.addEventListener('resize', resize);
    resize();

    // ----------------------------
    // Intro logic
    // ----------------------------
    const introScreen = document.getElementById('introScreen');
    const introVideo = document.getElementById('introVideo');
    const skipBtn = document.getElementById('skipBtn');
    const unmuteBtn = document.getElementById('unmuteIntroBtn');

    function endIntro() {
      if (introVideo) introVideo.pause();
      introScreen.classList.add('hidden');
      state = 'MENU';
      document.getElementById('startScreen').classList.remove('hidden');
    }

    if (introVideo) introVideo.addEventListener('ended', endIntro);
    if (skipBtn) skipBtn.addEventListener('click', endIntro);

    if (unmuteBtn) {
      unmuteBtn.addEventListener('click', () => {
        if (introVideo) introVideo.muted = false;
        unmuteBtn.classList.add('hidden');
      });
    }

    // ----------------------------
    // Game flow
    // ----------------------------
    function startGame() {
      const input = document.getElementById('playerNameInput');
      if (!input || input.value.trim() === '') { alert("Il faut un nom !"); return; }

      playerName = input.value.trim();
      if (audioCtx.state === 'suspended') audioCtx.resume();

      // optional fullscreen attempt
      toggleFullScreen();

      currentLevel = 0;
      penaltyTime = 0;
      winStartTime = 0;
      hasReversed = false;

      // chrono arm√©, mais pas forc√©ment lanc√© (niveau 1)
      timerRunning = false;
      startTime = 0;

      loadLevel(0);

      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('endScreen').classList.add('hidden');
      document.getElementById('gameUI').classList.remove('hidden');
      document.getElementById('gameOverlay').classList.remove('hidden');

      if (!gameLoopId) {
        lastTime = performance.now();
        gameLoopId = requestAnimationFrame(animate);
      }
    }

    function quitGame() {
      if (confirm("Abandonner l'examen ?")) {
        state = 'MENU';
        document.getElementById('gameUI').classList.add('hidden');
        document.getElementById('gameOverlay').classList.add('hidden');
        document.getElementById('startScreen').classList.remove('hidden');
      }
    }

    function loadLevel(idx) {
      state = 'PLAYING';

      // reset v√©hicule
      car.speed = 0;
      car.steering = 0;
      car.gear = 1;
      car.inputs.gas = false;
      car.inputs.brake = false;
      car.inputs.steerTarget = 0;
      updateGearUI();

      // reset sc√®ne
      obstacles = [];
      targetZone = null;
      winStartTime = 0;
      lastCrashTime = 0;

      // reset meta niveau
      levelMeta.slalomGates = [];
      levelMeta.slalomLastX = 0;

      const lvl = LEVELS[idx];
      lvl.setup();

      document.getElementById('levelName').innerText = lvl.title;
      document.getElementById('feedbackUI').classList.add('hidden');
    }

    function nextLevel() {
      currentLevel++;
      if (currentLevel >= LEVELS.length) finishExam();
      else loadLevel(currentLevel);
    }

    function finishExam() {
      state = 'FINISHED';

      // si chrono n'a jamais d√©marr√© (cas extr√™me), on le d√©marre pour √©viter NaN
      if (!startTime) startTime = Date.now();

      const finalTime = (Date.now() - startTime) / 1000 + penaltyTime;
      const finalTimeStr = finalTime.toFixed(2) + "s";

      document.getElementById('certName').innerText = playerName.toUpperCase();
      document.getElementById('certDate').innerText = new Date().toLocaleDateString();
      document.getElementById('certPenalties').innerText = "+" + penaltyTime.toFixed(0) + "s";
      document.getElementById('certTime').innerText = finalTimeStr;
      document.getElementById('certId').innerText = "#" + Math.floor(Math.random() * 9999).toString().padStart(4, "0");

      document.getElementById('gameUI').classList.add('hidden');
      document.getElementById('gameOverlay').classList.add('hidden');
      document.getElementById('endScreen').classList.remove('hidden');
    }

    // ----------------------------
    // Physics / controls
    // ----------------------------
    const keys = { up:false, down:false, left:false, right:false };

    window.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Shift','z','q','s','d'].includes(e.key)) e.preventDefault();
      switch(e.key){
        case 'ArrowLeft': case 'q': keys.left = true; break;
        case 'ArrowRight': case 'd': keys.right = true; break;
        case 'ArrowUp': case 'z': keys.up = true; break;
        case 'ArrowDown': case 's': keys.down = true; break;
        case ' ': case 'Shift': toggleGear(); break;
      }
    });

    window.addEventListener('keyup', (e) => {
      switch(e.key){
        case 'ArrowLeft': case 'q': keys.left = false; break;
        case 'ArrowRight': case 'd': keys.right = false; break;
        case 'ArrowUp': case 'z': keys.up = false; break;
        case 'ArrowDown': case 's': keys.down = false; break;
      }
    });

    function toggleGear() {
      car.gear *= -1;
      updateGearUI();
      playSound('click');
    }

    function updateGearUI() {
      const stick = document.getElementById('gearStick');
      if (!stick) return;
      if (car.gear === 1) {
        stick.innerText = "D";
        stick.className = "gear-stick gear-d";
      } else {
        stick.innerText = "R";
        stick.className = "gear-stick gear-r";
      }
    }

    // steering wheel
    const wheelZone = document.getElementById('wheelZone');
    const wheelVisual = document.getElementById('wheelVisual');
    let isSteering = false;
    let wheelTouchId = null;

    function handleSteer(cx, cy) {
      const rect = wheelZone.getBoundingClientRect();
      const center_x = rect.left + rect.width / 2;
      const center_y = rect.top + rect.height / 2;

      const dx = cx - center_x;
      const dy = cy - center_y;

      let angle = Math.atan2(dy, dx) * (180 / Math.PI);
      angle += 90;
      if (angle > 180) angle -= 360;
      if (angle < -180) angle += 360;

      const maxAngle = 110;
      angle = Math.max(-maxAngle, Math.min(maxAngle, angle));

      wheelVisual.style.transform = `rotate(${angle}deg)`;
      car.inputs.steerTarget = angle / maxAngle;
    }

    wheelZone.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.changedTouches[0];
      wheelTouchId = touch.identifier;
      isSteering = true;
      handleSteer(touch.clientX, touch.clientY);
    }, { passive:false });

    wheelZone.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isSteering) return;
      for (let i=0;i<e.changedTouches.length;i++){
        const t = e.changedTouches[i];
        if (t.identifier === wheelTouchId) handleSteer(t.clientX, t.clientY);
      }
    }, { passive:false });

    function endSteer(e) {
      for (let i=0;i<e.changedTouches.length;i++){
        const t = e.changedTouches[i];
        if (t.identifier === wheelTouchId){
          isSteering = false;
          wheelTouchId = null;
          if (!keys.left && !keys.right){
            car.inputs.steerTarget = 0;
            wheelVisual.style.transform = "rotate(0deg)";
          }
        }
      }
    }

    wheelZone.addEventListener('touchend', endSteer);
    wheelZone.addEventListener('touchcancel', endSteer);

    // mouse fallback
    wheelZone.addEventListener('mousedown', (e) => { isSteering = true; handleSteer(e.clientX, e.clientY); });
    window.addEventListener('mousemove', (e) => { if (isSteering) handleSteer(e.clientX, e.clientY); });
    window.addEventListener('mouseup', () => {
      isSteering = false;
      if (!keys.left && !keys.right){
        car.inputs.steerTarget = 0;
        wheelVisual.style.transform = "rotate(0deg)";
      }
    });

    // pedals
    const btnGas = document.getElementById('btnGas');
    const btnBrake = document.getElementById('btnBrake');
    const gearStick = document.getElementById('gearStick');

    btnGas.addEventListener('touchstart', (e)=>{ e.preventDefault(); car.inputs.gas = true; }, {passive:false});
    btnGas.addEventListener('touchend', (e)=>{ e.preventDefault(); car.inputs.gas = false; }, {passive:false});
    btnGas.addEventListener('mousedown', ()=> car.inputs.gas = true);
    btnGas.addEventListener('mouseup', ()=> car.inputs.gas = false);

    btnBrake.addEventListener('touchstart', (e)=>{ e.preventDefault(); car.inputs.brake = true; }, {passive:false});
    btnBrake.addEventListener('touchend', (e)=>{ e.preventDefault(); car.inputs.brake = false; }, {passive:false});
    btnBrake.addEventListener('mousedown', ()=> car.inputs.brake = true);
    btnBrake.addEventListener('mouseup', ()=> car.inputs.brake = false);

    gearStick.addEventListener('touchstart', (e)=>{ e.preventDefault(); toggleGear(); }, {passive:false});
    gearStick.addEventListener('mousedown', (e)=>{ e.preventDefault(); toggleGear(); });

    // buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('quitBtn').addEventListener('click', quitGame);
    document.getElementById('restartBtn').addEventListener('click', () => {
      document.getElementById('endScreen').classList.add('hidden');
      document.getElementById('startScreen').classList.remove('hidden');
      state = 'MENU';
    });

    // ----------------------------
    // Core update/draw loop
    // ----------------------------
    let lastTime = 0;

    function update(dt) {
      if (state !== 'PLAYING') return;

      // update niveau (feu / slalom, etc.)
      const lvl = LEVELS[currentLevel];
      if (lvl.update) lvl.update(dt);

      // chrono affichage
      let elapsed = 0;
      if (timerRunning && startTime) elapsed = (Date.now() - startTime) / 1000;
      elapsed += penaltyTime;
      document.getElementById('timerVal').innerText = elapsed.toFixed(2);

      // steering input
      handleSteeringInput(dt);

      // physique voiture
      const prevX = car.x, prevY = car.y, prevAngle = car.angle;

      const gas = car.inputs.gas || keys.up;
      const brake = car.inputs.brake || keys.down;

      if (car.gear === -1 && Math.abs(car.speed) > 0.12) hasReversed = true;

      // acc√©l√©ration + frein r√©alistes
      if (gas) {
        if (car.gear === 1 && car.speed < 4.2) car.speed += 0.18 * dt;
        if (car.gear === -1 && car.speed > -2.4) car.speed -= 0.14 * dt;
      } else if (brake) {
        if (car.speed > 0.12) car.speed -= 0.30 * dt;
        else if (car.speed < -0.12) car.speed += 0.30 * dt;
        else car.speed = 0;
      } else {
        // friction
        car.speed *= Math.pow(0.93, dt);
        if (Math.abs(car.speed) < 0.05) car.speed = 0;
      }

      // mouvement
      if (Math.abs(car.speed) > 0.01) {
        const angularVelocity = (car.speed / WHEELBASE) * Math.tan(car.steering);
        car.angle += angularVelocity * dt;
        car.x += car.speed * Math.cos(car.angle) * dt;
        car.y += car.speed * Math.sin(car.angle) * dt;
      }

      // collisions
      if (checkCollisions()) {
        car.x = prevX; car.y = prevY; car.angle = prevAngle;
        car.speed = -car.speed * 0.5;
      }

      // win check
      checkWin();
    }

    function handleSteeringInput(dt) {
      if (!isSteering) {
        if (keys.left) car.inputs.steerTarget = -1;
        else if (keys.right) car.inputs.steerTarget = 1;
        else car.inputs.steerTarget = 0;

        const targetAngle = car.inputs.steerTarget * 120;
        wheelVisual.style.transform = `rotate(${targetAngle}deg)`;
      }

      const steerSpeed = 0.10 * dt;
      const target = car.inputs.steerTarget * MAX_STEER;

      if (car.steering < target) car.steering = Math.min(target, car.steering + steerSpeed);
      if (car.steering > target) car.steering = Math.max(target, car.steering - steerSpeed);
    }

    function getCarCorners(c) {
      const cos = Math.cos(c.angle), sin = Math.sin(c.angle);
      const front = 30, back = 30, side = 15;
      return [
        { x: c.x + cos*front - sin*side, y: c.y + sin*front + cos*side },
        { x: c.x + cos*front + sin*side, y: c.y + sin*front - cos*side },
        { x: c.x - cos*back + sin*side, y: c.y - sin*back - cos*side },
        { x: c.x - cos*back - sin*side, y: c.y - sin*back + cos*side }
      ];
    }

    function checkCollisions() {
      const corners = getCarCorners(car);
      let hit = false;

      for (let obs of obstacles) {
        if (obs.type === 'cone') {
          for (let p of corners) {
            if (Math.hypot(p.x - obs.x, p.y - obs.y) < 11) hit = true;
          }
        } else if (obs.type === 'wall') {
          for (let p of corners) {
            if (p.x > obs.x - obs.w/2 && p.x < obs.x + obs.w/2 && p.y > obs.y - obs.h/2 && p.y < obs.y + obs.h/2) hit = true;
          }
        } else if (obs.type === 'car') {
          const w = 30, h = 60;
          for (let p of corners) {
            if (p.x > obs.x - w/2 && p.x < obs.x + w/2 && p.y > obs.y - h/2 && p.y < obs.y + h/2) hit = true;
          }
        }

        if (hit) {
          if (Date.now() - lastCrashTime > 1000) crash("Choc ! +5s");
          return true;
        }
      }

      // sortie √©cran = collision
      if (car.x < 0 || car.x > canvas.width || car.y < 0 || car.y > canvas.height) {
        if (Date.now() - lastCrashTime > 1000) crash("Sortie de route ! +5s");
        return true;
      }

      return false;
    }

    function crash(msg) {
      lastCrashTime = Date.now();
      penaltyTime += 5;
      playSound('crash');
      flashPenalty("+5s");

      // message neutre
      setMonitor(msg);

      car.speed = -car.speed * 0.5;
    }

    function isPointInTarget(p, t) {
      let tx = p.x - t.x, ty = p.y - t.y;
      let cos = Math.cos(-t.angle), sin = Math.sin(-t.angle);
      let rx = tx*cos - ty*sin;
      let ry = tx*sin + ty*cos;
      const tol = 3;
      return (rx > (-t.w/2 - tol) && rx < (t.w/2 + tol) && ry > (-t.h/2 - tol) && ry < (t.h/2 + tol));
    }

    function checkWin() {
      if (!targetZone) return;

      // doit √™tre (quasi) √† l‚Äôarr√™t
      if (Math.abs(car.speed) > 0.12) { winStartTime = 0; return; }

      const dx = car.x - targetZone.x;
      const dy = car.y - targetZone.y;
      const dist = Math.hypot(dx, dy);

      if (dist < 60) {
        if (winStartTime === 0) {
          // cr√©neau : marche arri√®re obligatoire
          if (currentLevel === 2 && !hasReversed) {
            setMonitor("Cr√©neau : passe en R au moins une fois.");
            return;
          }
          winStartTime = Date.now();
          setMonitor("Ne bouge plus‚Ä¶ validation ‚è≥");
        } else {
          if (Date.now() - winStartTime > 1300) {
            // pr√©cision : coins dans la zone
            const corners = getCarCorners(car);
            let cornersIn = 0;
            for (let p of corners) if (isPointInTarget(p, targetZone)) cornersIn++;

            let parkingPenalty = 0;
            let title = "", text = "";

            if (cornersIn === 4) {
              parkingPenalty = 0;
              title = "PARFAIT ‚úÖ";
              text = "Aucune p√©nalit√©.";
            } else {
              parkingPenalty = (4 - cornersIn) * 2;
              title = "VALID√â";
              text = `Pr√©cision : +${parkingPenalty}s`;
            }

            if (parkingPenalty > 0) penaltyTime += parkingPenalty;
            playSound('win');

            const f = document.getElementById('feedbackUI');
            document.getElementById('fbTitle').innerText = title;
            document.getElementById('fbText').innerText = text;
            document.getElementById('fbTitle').style.color = (parkingPenalty === 0) ? "#2ecc71" : "#f1c40f";
            document.getElementById('fbText').style.color = "#fff";
            f.classList.remove('hidden');
            setTimeout(() => f.classList.add('hidden'), 900);

            state = 'TRANSITION';
            winStartTime = 0;
            setTimeout(nextLevel, 900);
          }
        }
      } else {
        winStartTime = 0;
      }
    }

    function draw() {
      if (state !== 'PLAYING') {
        ctx.clearRect(0,0,canvas.width, canvas.height);
        return;
      }

      // fond asphalt
      ctx.fillStyle = asphaltPattern || '#555';
      ctx.fillRect(0,0,canvas.width, canvas.height);

      // dessin route selon niveau
      if (currentLevel === 0) drawRoadHorizontal(getCY(55), 180, true);
      if (currentLevel === 1) drawRoadHorizontal(getCY(55), 220, false);
      if (currentLevel === 2) drawCreneauScene(getCY(62));

      // zone cible
      if (targetZone) {
        ctx.save();
        ctx.translate(targetZone.x, targetZone.y);
        ctx.rotate(targetZone.angle);

        ctx.strokeStyle = 'rgba(46,204,113,0.95)';
        ctx.lineWidth = 4;
        ctx.setLineDash([10,10]);
        ctx.strokeRect(-targetZone.w/2, -targetZone.h/2, targetZone.w, targetZone.h);

        ctx.fillStyle = 'rgba(46,204,113,0.18)';
        ctx.fillRect(-targetZone.w/2, -targetZone.h/2, targetZone.w, targetZone.h);

        ctx.setLineDash([]);
        ctx.restore();
      }

      // obstacles
      for (let obs of obstacles) {
        if (obs.type === 'cone') {
          ctx.drawImage(coneImg, obs.x - 11, obs.y - 11, 22, 22);
        } else if (obs.type === 'wall') {
          ctx.fillStyle = 'rgba(200,200,200,0.90)';
          ctx.fillRect(obs.x - obs.w/2, obs.y - obs.h/2, obs.w, obs.h);
          ctx.strokeStyle = 'rgba(90,90,90,0.65)';
          ctx.strokeRect(obs.x - obs.w/2, obs.y - obs.h/2, obs.w, obs.h);
        } else if (obs.type === 'car') {
          ctx.save();
          ctx.translate(obs.x, obs.y);
          if (obs.angle) ctx.rotate(obs.angle);
          ctx.drawImage(carObsImg, -15, -30, 30, 60);
          ctx.restore();
        }
      }

      // feu (niveau 1)
      if (currentLevel === 0) drawTrafficLight(getCX(62), getCY(55) - 110);

      // voiture
      drawCar();
    }

    function drawRoadHorizontal(roadY, roadH, withStopLine) {
      ctx.fillStyle = 'rgba(0,0,0,0.16)';
      ctx.fillRect(0, roadY - roadH/2, canvas.width, roadH);

      // ligne m√©diane
      ctx.strokeStyle = 'rgba(255,255,255,0.85)';
      ctx.lineWidth = 4;
      ctx.setLineDash([18, 18]);
      ctx.beginPath();
      ctx.moveTo(0, roadY);
      ctx.lineTo(canvas.width, roadY);
      ctx.stroke();
      ctx.setLineDash([]);

      if (withStopLine) {
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(getCX(60), roadY + 10);
        ctx.lineTo(getCX(60), roadY + roadH/2 - 10);
        ctx.stroke();
      }
    }

    function drawCreneauScene(roadY) {
      // route en haut + trottoir
      ctx.fillStyle = 'rgba(0,0,0,0.16)';
      ctx.fillRect(0, 0, canvas.width, 130 + roadY);

      const curbY = roadY - 78;
      ctx.fillStyle = 'rgba(220,220,220,0.85)';
      ctx.fillRect(0, 0, canvas.width, curbY);

      ctx.strokeStyle = 'rgba(255,255,255,0.85)';
      ctx.lineWidth = 4;
      ctx.setLineDash([18,18]);
      ctx.beginPath();
      ctx.moveTo(0, roadY + 20);
      ctx.lineTo(canvas.width, roadY + 20);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawTrafficLight(x, y) {
      // bo√Ætier
      ctx.save();
      ctx.translate(x, y);

      ctx.fillStyle = 'rgba(20,20,20,0.85)';
      ctx.strokeStyle = 'rgba(255,255,255,0.20)';
      ctx.lineWidth = 2;
      roundRect(ctx, -20, -40, 40, 80, 10, true, true);

      // lampes
      const phase = levelMeta.traffic.phase;

      drawLamp(0, -22, phase === 'red' ? '#ff3b30' : 'rgba(255,59,48,0.18)');
      drawLamp(0, 0, phase === 'amber' ? '#ffcc00' : 'rgba(255,204,0,0.18)');
      drawLamp(0, 22, phase === 'green' ? '#34c759' : 'rgba(52,199,89,0.18)');

      ctx.restore();

      function drawLamp(cx, cy, color) {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(cx, cy, 10, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.stroke();
      }
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      if (typeof r === 'number') r = { tl:r, tr:r, br:r, bl:r };
      ctx.beginPath();
      ctx.moveTo(x + r.tl, y);
      ctx.lineTo(x + w - r.tr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      ctx.lineTo(x + w, y + h - r.br);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      ctx.lineTo(x + r.bl, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      ctx.lineTo(x, y + r.tl);
      ctx.quadraticCurveTo(x, y, x + r.tl, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawCar() {
      ctx.save();
      ctx.translate(car.x, car.y);
      ctx.rotate(car.angle + Math.PI/2);

      if (Date.now() - lastCrashTime < 900 && Math.floor(Date.now()/120) % 2 === 0) ctx.globalAlpha = 0.55;

      // ombre
      ctx.fillStyle = 'rgba(0,0,0,0.20)';
      ctx.beginPath();
      ctx.ellipse(0, 6, 14, 18, 0, 0, Math.PI*2);
      ctx.fill();

      // roues
      ctx.fillStyle = '#000';
      ctx.fillRect(-14, 15, 6, 12);
      ctx.fillRect(8, 15, 6, 12);

      ctx.save(); ctx.translate(-11, -20); ctx.rotate(car.steering); ctx.fillRect(-3, -6, 6, 12); ctx.restore();
      ctx.save(); ctx.translate(11, -20); ctx.rotate(car.steering); ctx.fillRect(-3, -6, 6, 12); ctx.restore();

      // carrosserie
      ctx.drawImage(carImg, -15, -30, 30, 60);

      // feux stop
      if (car.inputs.brake || keys.down) {
        ctx.fillStyle = 'rgba(255,0,0,0.6)';
        ctx.shadowColor = 'rgba(255,0,0,0.65)';
        ctx.shadowBlur = 16;
        ctx.fillRect(-12, 26, 6, 3);
        ctx.fillRect(6, 26, 6, 3);
        ctx.shadowBlur = 0;
      }

      // marche arri√®re
      if (car.gear === -1) {
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillRect(-8, 26, 4, 3);
      }

      ctx.restore();
    }

    function animate(t) {
      gameLoopId = requestAnimationFrame(animate);
      if (!lastTime) { lastTime = t; return; }
      const dt = (t - lastTime) / 16.67;
      lastTime = t;
      update(dt);
      draw();
    }

    // start screens
    // (si la vid√©o n'est pas dispo, on passe direct)
    setTimeout(() => {
      if (state === 'INTRO' && (!introVideo || introVideo.readyState < 2)) {
        endIntro();
      }
    }, 2200);
  </script>
</body>
</html>
